// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { toast } from 'sonner';
import { v4 as uuidv4 } from 'uuid';
import { errorHandler } from '@/services/ErrorHandlingService';
import { debounce } from 'lodash';
import { cacheService } from '@/services/CacheService';
import { FREQUENTLY_ACCESSED_TABLES, getTableCacheTTL, TableName } from '@/constants/tables';
import { useEventsStore } from '@/services/events';

// Get environment variables with fallbacks
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://yfufpcxkerovnijhodrr.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlmdWZwY3hrZXJvdm5pamhvZHJyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIyNjI3ODYsImV4cCI6MjA1NzgzODc4Nn0.1x7WAfVIvlm-KPy2q4eFylaVtdc5_ZJmlis5AMJ-Izc";

// Check that environment variables are set in non-development environments
if (import.meta.env.PROD && (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY)) {
  console.error('Supabase environment variables are not set in production mode!');
  // In production, we'll log an error but still use the fallback values
}

// Store connection status
let isSupabaseConnected = false;
let connectionAttempts = 0;
let lastConnectionStatus = null;
let connectionStatusTimeout: ReturnType<typeof setTimeout> | null = null;
let connectionStabilityTimeout: ReturnType<typeof setTimeout> | null = null;
let lastConnectionCheckTime = 0;
const CONNECTION_CHECK_INTERVAL = 30000; // 30 seconds
const STABILITY_THRESHOLD = 5000; // 5 seconds of stable connection before state change
const MAX_CONNECTION_ATTEMPTS = 5;

// Constants
const SUPABASE_CACHE_NAMESPACE = 'supabase';
// Remove hardcoded table names in favor of imported constants
// const FREQUENTLY_ACCESSED_TABLES = ['calls', 'call_transcripts', 'keyword_trends', 'sentiment_trends'];
const FREQUENT_TABLE_TTL = 2000; // 2 seconds TTL for frequently accessed tables
const STANDARD_TABLE_TTL = 5000; // 5 seconds TTL for other tables
const MAX_RETRY_ATTEMPTS = 3;
const MAX_OFFLINE_QUEUE_SIZE = 100; // Limit queue size to prevent memory issues
const MAX_OFFLINE_QUEUE_RETRY = 3; // Maximum retries for offline queue items

// Queue for storing operations when offline
interface OfflineQueueItem {
  operation: string;
  callback: () => Promise<void>;
  retryCount: number;
  id: string; // Unique ID for tracking
  timestamp: number; // When it was added
}

const offlineQueue: OfflineQueueItem[] = [];

// Pending request lock to prevent race conditions
const pendingRequests = new Map<string, Promise<any>>();

// Debounced log function to prevent console spam
const debouncedLog = debounce((message: string) => {
  console.log(message);
}, 1000, { leading: true, trailing: false });

// Create a supabase client with auto-refresh and retries
export const supabase = createClient<Database>(
  SUPABASE_URL,
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
    },
    global: {
      fetch: async (...args: [RequestInfo | URL, RequestInit?]): Promise<Response> => {
        const [url, options] = args;
        
        // Create a cache key based on the request
        const cacheKey = `${options?.method || 'GET'}-${url.toString()}`;
        const requestId = uuidv4();
        const isReadOperation = !options?.method || options?.method === 'GET';
        const isWriteOperation = options?.method === 'POST' || options?.method === 'PUT' || options?.method === 'PATCH';
        
        // Check if we're offline before making the request
        if (errorHandler.isOffline && !url.toString().includes('connection-check')) {
          console.log(`Offline: Skipping request to ${url}`);
          return Promise.reject(new Error('You are currently offline - operation queued'));
        }
        
        // Determine if this request is for a frequently accessed table
        const isFrequentlyAccessedTable = FREQUENTLY_ACCESSED_TABLES.some(table => 
          url.toString().includes(table)
        );
        
        // Set appropriate TTL
        const ttl = isFrequentlyAccessedTable ? FREQUENT_TABLE_TTL : STANDARD_TABLE_TTL;
        
        // For read operations, check cache first
        if (isReadOperation) {
          // Check if we have a cached response
          const cachedData = cacheService.get<Record<string, unknown>>(
            cacheKey, 
            { namespace: SUPABASE_CACHE_NAMESPACE, ttl }
          );
          
          if (cachedData) {
            console.log(`Using cached response for ${url}`);
            return new Response(
              JSON.stringify(cachedData),
              { status: 200, headers: { 'Content-Type': 'application/json' } }
            );
          }
          
          // Check if there's already a request in progress - use lock to prevent race conditions
          if (pendingRequests.has(cacheKey)) {
            console.log(`Merging duplicate request for ${url} - using lock to prevent race condition`);
            
            try {
              // Wait for the in-progress request to complete and return its result
              const responseData = await pendingRequests.get(cacheKey);
              
              // Return a new response with the data
              return new Response(
                JSON.stringify(responseData),
                { status: 200, headers: { 'Content-Type': 'application/json' } }
              );
            } catch (error) {
              // If waiting for the in-progress request fails, continue with a new request
              console.warn(`Error waiting for in-progress request: ${error instanceof Error ? error.message : String(error)}`);
              // Fall through to make a new request
            }
          }
          
          // Create a lock for this request
          const requestPromise = (async () => {
            try {
              // Use the native fetch function
              const response = await fetch(url, options);
              
              // For successful operations, parse and return the data
              if (response.ok) {
                const responseData = await response.json();
                
                // Cache the result
                cacheService.set(
                  cacheKey, 
                  responseData, 
                  { namespace: SUPABASE_CACHE_NAMESPACE, ttl }
                );
                
                return responseData;
              } else {
                throw new Error(`Request failed with status ${response.status}`);
              }
            } catch (error) {
              // Remove this request from pending map
              pendingRequests.delete(cacheKey);
              throw error;
            }
          })();
          
          // Store the promise for other requests to use
          pendingRequests.set(cacheKey, requestPromise);
          
          // Set a timeout to remove the lock to prevent memory leaks
          setTimeout(() => {
            pendingRequests.delete(cacheKey);
          }, ttl + 1000); // Use TTL plus buffer time
          
          try {
            // Wait for the request to complete
            const responseData = await requestPromise;
            
            // Return a new response with the data
            return new Response(
              JSON.stringify(responseData),
              { status: 200, headers: { 'Content-Type': 'application/json' } }
            );
          } catch (error) {
            // Remove this request from pending map
            pendingRequests.delete(cacheKey);
            throw error;
          }
        } else if (isWriteOperation) {
          // For write operations, clear any cached read results for this table
          // This ensures that subsequent reads will fetch fresh data
          const tableMatch = FREQUENTLY_ACCESSED_TABLES.find(table => 
            url.toString().includes(table)
          );
          if (tableMatch) {
            // Clear cached entries for this table
            const tablePattern = new RegExp(`GET.*${tableMatch}`);
            const cacheKeys = Array.from(cacheService['caches'].get(SUPABASE_CACHE_NAMESPACE)?.keys() || []);
            
            for (const key of cacheKeys) {
              if (tablePattern.test(key)) {
                cacheService.delete(key, { namespace: SUPABASE_CACHE_NAMESPACE });
              }
            }
            
            // Also clear any pending requests to avoid race conditions
            for (const [key, _] of pendingRequests.entries()) {
              if (tablePattern.test(key)) {
                pendingRequests.delete(key);
              }
            }
          }
        }
        
        // Add our own retry logic to handle network failures
        let attempt = 1;
        
        while (attempt <= MAX_RETRY_ATTEMPTS) {
          try {
            // Use the native fetch function
            const response = await fetch(url, options);
            
            // Return the response
            return response;
          } catch (error) {
            // If this is the last attempt, or if we're offline, fail
            if (attempt === MAX_RETRY_ATTEMPTS || errorHandler.isOffline) {
              console.error(`Supabase fetch attempt ${attempt} failed:`, error);
              throw error;
            }
            
            // Exponential backoff for retries
            const backoffMs = Math.pow(2, attempt) * 100;
            console.log(`Fetch attempt ${attempt} failed, retrying in ${backoffMs}ms...`);
            await new Promise(resolve => setTimeout(resolve, backoffMs));
            attempt++;
          }
        }
        
        // This code should never be reached due to the throw in the catch block
        throw new Error('Unexpected end of fetch function');
      },
    },
  }
);

// Register auth state change listener
supabase.auth.onAuthStateChange((event, session) => {
  console.log('Auth state changed:', event);
  
  if (event === 'SIGNED_IN') {
    console.log('User signed in');
    connectionAttempts = 0;
    checkSupabaseConnection();
  } else if (event === 'SIGNED_OUT') {
    console.log('User signed out');
    updateConnectionStatus(false);
  }
});

// Process offline queue when back online
const processOfflineQueue = async () => {
  if (offlineQueue.length === 0 || errorHandler.isOffline) {
    return;
  }
  
  console.log(`Processing offline queue (${offlineQueue.length} operations)`);
  
  // Sort by timestamp (oldest first)
  const operations = [...offlineQueue].sort((a, b) => a.timestamp - b.timestamp);
  offlineQueue.length = 0; // Clear the queue
  
  // Group operations by type to optimize processing
  const operationGroups: { [key: string]: OfflineQueueItem[] } = {};
  for (const item of operations) {
    const opType = item.operation.split(':')[0]; // Extract operation type
    if (!operationGroups[opType]) {
      operationGroups[opType] = [];
    }
    operationGroups[opType].push(item);
  }
  
  // Process each group in order
  for (const [opType, items] of Object.entries(operationGroups)) {
    console.log(`Processing ${items.length} operations of type ${opType}`);
    
    for (const item of items) {
      try {
        console.log(`Executing queued operation: ${item.operation} (attempt ${item.retryCount + 1})`);
        await item.callback();
      } catch (error) {
        console.error(`Failed to execute queued operation ${item.operation}:`, error);
        
        // If we've gone offline while processing, re-queue the remaining operations
        if (errorHandler.isOffline) {
          console.log('Back offline, re-queuing remaining operations');
          
          // Re-queue current item if it hasn't exceeded retry count
          if (item.retryCount < MAX_OFFLINE_QUEUE_RETRY) {
            offlineQueue.push({
              ...item,
              retryCount: item.retryCount + 1,
              timestamp: Date.now() // Update timestamp
            });
          }
          
          // Re-queue remaining operations
          const remainingItems = items.slice(items.indexOf(item) + 1);
          offlineQueue.push(...remainingItems);
          
          // Re-queue operations from other groups
          for (const [otherType, otherItems] of Object.entries(operationGroups)) {
            if (otherType !== opType) {
              offlineQueue.push(...otherItems);
            }
          }
          
          break;
        } else if (item.retryCount < MAX_OFFLINE_QUEUE_RETRY) {
          // If failed but we're still online, re-queue with incremented retry count
          offlineQueue.push({
            ...item,
            retryCount: item.retryCount + 1,
            timestamp: Date.now() // Update timestamp
          });
        } else {
          console.error(`Operation ${item.operation} exceeded maximum retry count, abandoning`);
          // Could dispatch an event or notification here
        }
      }
    }
    
    // If we went offline, stop processing
    if (errorHandler.isOffline) {
      break;
    }
  }
};

// Debounced function to update connection status
const updateConnectionStatus = debounce((online: boolean) => {
  console.log(`[CONNECTION DEBUG] updateConnectionStatus called with online=${online}, last status was ${lastConnectionStatus}`);
  
  // Check if the errorHandler's offline state matches what we expect
  const currentOfflineState = errorHandler.isOffline;
  
  // Don't update if the status hasn't changed and errorHandler state is correct
  if (lastConnectionStatus === online && currentOfflineState === !online) {
    console.log(`[CONNECTION DEBUG] Connection status unchanged, skipping update`);
    return;
  } else if (lastConnectionStatus === online && currentOfflineState !== !online) {
    console.log(`[CONNECTION DEBUG] Connection status unchanged, but errorHandler state needs sync`);
    // Update errorHandler state to match our expected state
    errorHandler.setOffline(!online);
    return;
  }
  
  // Clear any pending stability timeout
  if (connectionStabilityTimeout) {
    clearTimeout(connectionStabilityTimeout);
    connectionStabilityTimeout = null;
  }
  
  // Set a timeout to allow for connection to stabilize
  connectionStabilityTimeout = setTimeout(() => {
    // Recheck conditions after stability period
    if (lastConnectionStatus !== online) {
      console.log(`[CONNECTION DEBUG] Updating connection status after stability period: ${online ? 'online' : 'offline'}`);
      isSupabaseConnected = online;
      lastConnectionStatus = online;
      
      console.log(`Connection status updated: ${online ? 'online' : 'offline'}`);
      
      if (online) {
        console.log('[CONNECTION DEBUG] Setting errorHandler.isOffline to false');
        errorHandler.setOffline(false);
        // Process any queued operations when coming back online
        processOfflineQueue();
        
        // Check localStorage for any pending uploads that need processing
        try {
          const pendingUploads = localStorage.getItem('pendingUploads');
          if (pendingUploads) {
            // Don't process here, just dispatch event to notify upload processor
            console.log('[CONNECTION DEBUG] Found pending uploads in localStorage, dispatching event');
            window.dispatchEvent(new CustomEvent('pending-uploads-check', {
              detail: { count: JSON.parse(pendingUploads).length }
            }));
          }
        } catch (e) {
          console.error('[CONNECTION DEBUG] Error checking for pending uploads:', e);
        }
      } else {
        console.log('[CONNECTION DEBUG] Setting errorHandler.isOffline to true');
        errorHandler.setOffline(true);
      }
      
      try {
        // Dispatch a single event instead of multiple
        const eventName = online ? 'connection-restored' : 'connection-lost';
        console.log(`[CONNECTION DEBUG] Dispatching event: ${eventName}`);
        // Dispatch both events - the legacy supabase event and our custom event
        window.dispatchEvent(new Event(`supabase-${eventName}`));
        
        // Also dispatch our custom event for the application
        const { dispatchEvent } = useEventsStore.getState();
        dispatchEvent(eventName, { 
          timestamp: Date.now(),
          retryCount: connectionAttempts,
          backoffTime: online ? 0 : Math.min(300000, Math.pow(2, connectionAttempts) * 1000)
        });
      } catch (error) {
        console.error('[CONNECTION DEBUG] Error dispatching connection event:', error);
      }
      
      // Remove any console.log warnings if the connection is successful
      if (online) {
        try {
          const warningElements = document.querySelectorAll('[data-testid="toast-warning"]');
          if (warningElements.length > 0) {
            console.log('[CONNECTION DEBUG] Removing connection warning toasts');
            warningElements.forEach(el => {
              if (el.textContent?.includes('Connection')) {
                el.remove();
              }
            });
          }
        } catch (error) {
          console.error('[CONNECTION DEBUG] Error removing toast warnings:', error);
        }
      }
    } else {
      console.log(`[CONNECTION DEBUG] Connection status unchanged during stability period`);
    }
    
    // Need to explicitly declare as null, not reassign
    window.setTimeout(() => {
      connectionStabilityTimeout = null;
    }, 0);
  }, STABILITY_THRESHOLD);
}, 2000, { leading: false, trailing: true }); // 2 second debounce with trailing edge execution

/**
 * A more resilient connection check that doesn't depend on specific tables or RPC
 * @returns Promise<boolean> - true if connected, false otherwise
 */
export const checkSupabaseConnection = async (): Promise<boolean> => {
  try {
    console.log('[CONNECTION DEBUG] Starting connection check, current status:', {
      isSupabaseConnected,
      connectionAttempts,
      lastConnectionStatus,
      isOffline: errorHandler.isOffline,
      browserOnline: typeof navigator !== 'undefined' && navigator.onLine
    });
    
    // If the browser reports we're offline, don't even try
    if (typeof navigator !== 'undefined' && !navigator.onLine) {
      console.log('[CONNECTION DEBUG] Browser reports offline, skipping connection check');
      updateConnectionStatus(false);
      return false;
    }
    
    // Check if the Supabase server is reachable using a simple HEAD request
    console.log('[CONNECTION DEBUG] Attempting HEAD request to Supabase');
    const response = await fetch(`${SUPABASE_URL}/rest/v1/`, {
      method: 'HEAD',
      headers: {
        'Content-Type': 'application/json',
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        // Add required headers for Supabase
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
      }
    });
    
    console.log('[CONNECTION DEBUG] Supabase HEAD response:', {
      status: response.status,
      statusText: response.statusText,
      headers: Array.from(response.headers.entries())
    });
    
    // Consider connected if the server responds with any status < 500 (server error)
    const isConnected = response.status < 500;
    
    console.log('[CONNECTION DEBUG] Connection check result:', {
      isConnected,
      status: response.status,
      previousStatus: isSupabaseConnected
    });
    
    // Update internal states
    if (isConnected) {
      // Reset connection attempts on success
      connectionAttempts = 0;
      // Skip warning message on successful connection
      console.log('[CONNECTION DEBUG] Connection check successful');
    } else {
      connectionAttempts++;
      console.log(`[CONNECTION DEBUG] Connection attempt ${connectionAttempts} failed`);
    }
    
    // Always update connection status based on the result
    updateConnectionStatus(isConnected);
    return isConnected;
  } catch (error) {
    console.error('[CONNECTION DEBUG] Supabase connection check failed with exception:', error);
    isSupabaseConnected = false;
    connectionAttempts++;
    console.log(`[CONNECTION DEBUG] Connection attempt ${connectionAttempts} failed with exception`);
    updateConnectionStatus(false);
    return false;
  }
};

// Check connection status
export const isConnected = () => isSupabaseConnected;

// Generate a proper anonymous user ID using the uuid library
export const generateAnonymousUserId = () => {
  const anonymousId = `anonymous-${uuidv4()}`;
  return anonymousId;
};

// Preload an audio file from Supabase Storage
export const preloadAudioFile = async (bucketName: string, filePath: string): Promise<Blob | null> => {
  try {
    console.log(`Preloading audio file from Supabase Storage: ${bucketName}/${filePath}`);
    
    // First check if we're online
    if (errorHandler.isOffline) {
      console.warn('Cannot preload audio file: offline');
      throw new Error('Unable to download audio file: you are offline');
    }
    
    // Create signed URL for faster access
    const { data: signedURLData, error: signedURLError } = await supabase
      .storage
      .from(bucketName)
      .createSignedUrl(filePath, 60); // 60 seconds expiry
    
    if (signedURLError || !signedURLData?.signedUrl) {
      console.error('Error creating signed URL:', signedURLError);
      
      // Fall back to public URL
      const { data: publicURLData } = await supabase
        .storage
        .from(bucketName)
        .getPublicUrl(filePath);
      
      if (!publicURLData?.publicUrl) {
        throw new Error(`Failed to get URL for file: ${filePath}`);
      }
      
      console.log('Using public URL as fallback');
      const response = await fetch(publicURLData.publicUrl);
      if (!response.ok) {
        throw new Error(`Failed to download file: ${response.status} ${response.statusText}`);
      }
      
      return await response.blob();
    }
    
    // Use the signed URL for faster downloads
    console.log('Using signed URL for faster download');
    const response = await fetch(signedURLData.signedUrl);
    if (!response.ok) {
      throw new Error(`Failed to download file: ${response.status} ${response.statusText}`);
    }
    
    const blob = await response.blob();
    console.log(`Successfully downloaded ${blob.size} bytes`);
    return blob;
  } catch (error) {
    console.error('Error preloading audio file:', error);
    return null;
  }
};

// Start periodic connection checks
let connectionCheckInterval: ReturnType<typeof setInterval> | null = null;

const startConnectionChecks = () => {
  if (connectionCheckInterval) {
    clearInterval(connectionCheckInterval);
  }
  
  connectionCheckInterval = setInterval(() => {
    checkSupabaseConnection();
  }, CONNECTION_CHECK_INTERVAL);
  
  // Initial check
  checkSupabaseConnection();
};

// Start connection checks
startConnectionChecks();
