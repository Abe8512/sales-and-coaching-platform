// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { toast } from 'sonner';
import { v4 as uuidv4 } from 'uuid';
import { errorHandler } from '@/services/ErrorHandlingService';
import { debounce } from 'lodash';
import { cacheService } from '@/services/CacheService';
import { FREQUENTLY_ACCESSED_TABLES, getTableCacheTTL, TableName } from '@/constants/tables';
import { useEventsStore } from '@/services/events';

// Define ENV Vars at the top level
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://yfufpcxkerovnijhodrr.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlmdWZwY3hrZXJvdm5pamhvZHJyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIyNjI3ODYsImV4cCI6MjA1NzgzODc4Nn0.1x7WAfVIvlm-KPy2q4eFylaVtdc5_ZJmlis5AMJ-Izc";

// Check that environment variables are set in non-development environments
if (import.meta.env.PROD && (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY)) {
  console.error('Supabase environment variables are not set in production mode!');
}

// --- Ensure Singleton Client Instance ---
let supabaseInstance: ReturnType<typeof createClient<Database>> | null = null;

const createSupabaseClient = () => {
  if (supabaseInstance) {
      return supabaseInstance;
  }
  
  console.log("[Supabase Client] Creating new singleton instance...");

  supabaseInstance = createClient<Database>(
    SUPABASE_URL,
    SUPABASE_PUBLISHABLE_KEY,
    {
      auth: {
        autoRefreshToken: true,
        persistSession: true,
      },
      global: {
        fetch: async (...args: [RequestInfo | URL, RequestInit?]): Promise<Response> => {
          const [url, options] = args;
          const cacheKey = `${options?.method || 'GET'}-${url.toString()}`;
          const isReadOperation = !options?.method || options?.method === 'GET';
          const isWriteOperation = options?.method === 'POST' || options?.method === 'PUT' || options?.method === 'PATCH';
          
          if (errorHandler.isOffline && !url.toString().includes('connection-check')) {
            return Promise.reject(new Error('You are currently offline - operation queued'));
          }

          const isFrequentlyAccessedTable = FREQUENTLY_ACCESSED_TABLES.some(table => url.toString().includes(table));
          const ttl = isFrequentlyAccessedTable ? FREQUENT_TABLE_TTL : STANDARD_TABLE_TTL;

          if (isReadOperation) {
            const cachedData = cacheService.get<Record<string, unknown>>(cacheKey, { namespace: SUPABASE_CACHE_NAMESPACE, ttl });
            if (cachedData) {
              return new Response(JSON.stringify(cachedData), { status: 200, headers: { 'Content-Type': 'application/json' } });
            }
            if (pendingRequests.has(cacheKey)) {
               try {
                  const responseData = await pendingRequests.get(cacheKey);
                  return new Response(JSON.stringify(responseData), { status: 200, headers: { 'Content-Type': 'application/json' } });
               } catch (error) {
                   console.warn(`Error waiting for in-progress request: ${error instanceof Error ? error.message : String(error)}`);
               }
            }
            const requestPromise = (async () => {
              try {
                const response = await fetch(url, options);
                
                if (response.ok) {
                  const responseData = await response.json();
                  
                  cacheService.set(
                    cacheKey, 
                    responseData, 
                    { namespace: SUPABASE_CACHE_NAMESPACE, ttl }
                  );
                  
                  return responseData;
                } else {
                  throw new Error(`Request failed with status ${response.status}`);
                }
              } catch (error) {
                pendingRequests.delete(cacheKey);
                throw error;
              }
            })();
            pendingRequests.set(cacheKey, requestPromise);
            setTimeout(() => { pendingRequests.delete(cacheKey); }, ttl + 1000);
            try {
               const responseData = await requestPromise;
               return new Response(JSON.stringify(responseData), { status: 200, headers: { 'Content-Type': 'application/json' } });
            } catch (error) {
               pendingRequests.delete(cacheKey);
               throw error;
            }
          } else if (isWriteOperation) {
            const tableMatch = FREQUENTLY_ACCESSED_TABLES.find(table => 
              url.toString().includes(table)
            );
            if (tableMatch) {
              const tablePattern = new RegExp(`GET.*${tableMatch}`);
              const cacheKeys = Array.from(cacheService['caches'].get(SUPABASE_CACHE_NAMESPACE)?.keys() || []);
              
              for (const key of cacheKeys) {
                if (tablePattern.test(key)) {
                  cacheService.delete(key, { namespace: SUPABASE_CACHE_NAMESPACE });
                }
              }
              
              for (const [key, _] of pendingRequests.entries()) {
                if (tablePattern.test(key)) {
                  pendingRequests.delete(key);
                }
              }
            }
          }

          let attempt = 1;
          while (attempt <= MAX_RETRY_ATTEMPTS) {
             try {
                const response = await fetch(url, options);
                return response;
             } catch (error) {
                if (attempt === MAX_RETRY_ATTEMPTS || errorHandler.isOffline) throw error;
                const backoffMs = Math.pow(2, attempt) * 100;
                await new Promise(resolve => setTimeout(resolve, backoffMs));
                attempt++;
             }
          }
          throw new Error('Unexpected end of fetch function');
        },
      },
    }
  );
  
  // --- Attach Listener to the Singleton Instance --- 
  supabaseInstance.auth.onAuthStateChange((event, session) => {
    console.log('[Singleton Client] Auth state changed:', event);
    
    if (event === 'SIGNED_IN') {
      console.log('[Singleton Client] User signed in');
      connectionAttempts = 0;
      checkSupabaseConnection();
    } else if (event === 'SIGNED_OUT') {
      console.log('[Singleton Client] User signed out');
      updateConnectionStatus(false);
    }
  });
  
  return supabaseInstance;
}
// --- End Singleton Client Instance ---

// Export the single instance directly
export const supabase = createSupabaseClient();

// Store connection status
let isSupabaseConnected = false;
let connectionAttempts = 0;
let lastConnectionStatus = null;
let connectionStatusTimeout: ReturnType<typeof setTimeout> | null = null;
let connectionStabilityTimeout: ReturnType<typeof setTimeout> | null = null;
let lastConnectionCheckTime = 0;
const CONNECTION_CHECK_INTERVAL = 30000; // 30 seconds
const STABILITY_THRESHOLD = 5000; // 5 seconds of stable connection before state change
const MAX_CONNECTION_ATTEMPTS = 5;

// Constants
const SUPABASE_CACHE_NAMESPACE = 'supabase';
// Remove hardcoded table names in favor of imported constants
// const FREQUENTLY_ACCESSED_TABLES = ['calls', 'call_transcripts', 'keyword_trends', 'sentiment_trends'];
const FREQUENT_TABLE_TTL = 2000; // 2 seconds TTL for frequently accessed tables
const STANDARD_TABLE_TTL = 5000; // 5 seconds TTL for other tables
const MAX_RETRY_ATTEMPTS = 3;
const MAX_OFFLINE_QUEUE_SIZE = 100; // Limit queue size to prevent memory issues
const MAX_OFFLINE_QUEUE_RETRY = 3; // Maximum retries for offline queue items

// Queue for storing operations when offline
interface OfflineQueueItem {
  operation: string;
  callback: () => Promise<void>;
  retryCount: number;
  id: string; // Unique ID for tracking
  timestamp: number; // When it was added
}

const offlineQueue: OfflineQueueItem[] = [];

// Pending request lock to prevent race conditions
const pendingRequests = new Map<string, Promise<any>>();

// Debounced log function to prevent console spam
const debouncedLog = debounce((message: string) => {
  console.log(message);
}, 1000, { leading: true, trailing: false });

// Process offline queue when back online
const processOfflineQueue = async () => {
  if (offlineQueue.length === 0 || errorHandler.isOffline) {
    return;
  }
  
  console.log(`Processing offline queue (${offlineQueue.length} operations)`);
  
  // Sort by timestamp (oldest first)
  const operations = [...offlineQueue].sort((a, b) => a.timestamp - b.timestamp);
  offlineQueue.length = 0; // Clear the queue
  
  // Group operations by type to optimize processing
  const operationGroups: { [key: string]: OfflineQueueItem[] } = {};
  for (const item of operations) {
    const opType = item.operation.split(':')[0]; // Extract operation type
    if (!operationGroups[opType]) {
      operationGroups[opType] = [];
    }
    operationGroups[opType].push(item);
  }
  
  // Process each group in order
  for (const [opType, items] of Object.entries(operationGroups)) {
    console.log(`Processing ${items.length} operations of type ${opType}`);
    
    for (const item of items) {
      try {
        console.log(`Executing queued operation: ${item.operation} (attempt ${item.retryCount + 1})`);
        await item.callback();
      } catch (error) {
        console.error(`Failed to execute queued operation ${item.operation}:`, error);
        
        // If we've gone offline while processing, re-queue the remaining operations
        if (errorHandler.isOffline) {
          console.log('Back offline, re-queuing remaining operations');
          
          // Re-queue current item if it hasn't exceeded retry count
          if (item.retryCount < MAX_OFFLINE_QUEUE_RETRY) {
            offlineQueue.push({
              ...item,
              retryCount: item.retryCount + 1,
              timestamp: Date.now() // Update timestamp
            });
          }
          
          // Re-queue remaining operations
          const remainingItems = items.slice(items.indexOf(item) + 1);
          offlineQueue.push(...remainingItems);
          
          // Re-queue operations from other groups
          for (const [otherType, otherItems] of Object.entries(operationGroups)) {
            if (otherType !== opType) {
              offlineQueue.push(...otherItems);
            }
          }
          
          break;
        } else if (item.retryCount < MAX_OFFLINE_QUEUE_RETRY) {
          // If failed but we're still online, re-queue with incremented retry count
          offlineQueue.push({
            ...item,
            retryCount: item.retryCount + 1,
            timestamp: Date.now() // Update timestamp
          });
        } else {
          console.error(`Operation ${item.operation} exceeded maximum retry count, abandoning`);
          // Could dispatch an event or notification here
        }
      }
    }
    
    // If we went offline, stop processing
    if (errorHandler.isOffline) {
      break;
    }
  }
};

// Debounced function to update connection status
const updateConnectionStatus = debounce((online: boolean) => {
  console.log(`[CONNECTION DEBUG] updateConnectionStatus called with online=${online}, last status was ${lastConnectionStatus}`);
  
  // Check if the errorHandler's offline state matches what we expect
  const currentOfflineState = errorHandler.isOffline;
  
  // Don't update if the status hasn't changed and errorHandler state is correct
  if (lastConnectionStatus === online && currentOfflineState === !online) {
    console.log(`[CONNECTION DEBUG] Connection status unchanged, skipping update`);
    return;
  } else if (lastConnectionStatus === online && currentOfflineState !== !online) {
    console.log(`[CONNECTION DEBUG] Connection status unchanged, but errorHandler state needs sync`);
    // Update errorHandler state to match our expected state
    errorHandler.setOffline(!online);
    return;
  }
  
  // Clear any pending stability timeout
  if (connectionStabilityTimeout) {
    clearTimeout(connectionStabilityTimeout);
    connectionStabilityTimeout = null;
  }
  
  // Set a timeout to allow for connection to stabilize
  connectionStabilityTimeout = setTimeout(() => {
    // Recheck conditions after stability period
    if (lastConnectionStatus !== online) {
      console.log(`[CONNECTION DEBUG] Updating connection status after stability period: ${online ? 'online' : 'offline'}`);
      isSupabaseConnected = online;
      lastConnectionStatus = online;
      
      console.log(`Connection status updated: ${online ? 'online' : 'offline'}`);
      
      if (online) {
        console.log('[CONNECTION DEBUG] Setting errorHandler.isOffline to false');
        errorHandler.setOffline(false);
        // Process any queued operations when coming back online
        processOfflineQueue();
        
        // Check localStorage for any pending uploads that need processing
        try {
          const pendingUploads = localStorage.getItem('pendingUploads');
          if (pendingUploads) {
            // Don't process here, just dispatch event to notify upload processor
            console.log('[CONNECTION DEBUG] Found pending uploads in localStorage, dispatching event');
            window.dispatchEvent(new CustomEvent('pending-uploads-check', {
              detail: { count: JSON.parse(pendingUploads).length }
            }));
          }
        } catch (e) {
          console.error('[CONNECTION DEBUG] Error checking for pending uploads:', e);
        }
      } else {
        console.log('[CONNECTION DEBUG] Setting errorHandler.isOffline to true');
        errorHandler.setOffline(true);
      }
      
      try {
        // Dispatch a single event instead of multiple
        const eventName = online ? 'connection-restored' : 'connection-lost';
        console.log(`[CONNECTION DEBUG] Dispatching event: ${eventName}`);
        // Dispatch both events - the legacy supabase event and our custom event
        window.dispatchEvent(new Event(`supabase-${eventName}`));
        
        // Also dispatch our custom event for the application
        const { dispatchEvent } = useEventsStore.getState();
        dispatchEvent(eventName, { 
          timestamp: Date.now(),
          retryCount: connectionAttempts,
          backoffTime: online ? 0 : Math.min(300000, Math.pow(2, connectionAttempts) * 1000)
        });
      } catch (error) {
        console.error('[CONNECTION DEBUG] Error dispatching connection event:', error);
      }
      
      // Remove any console.log warnings if the connection is successful
      if (online) {
        try {
          const warningElements = document.querySelectorAll('[data-testid="toast-warning"]');
          if (warningElements.length > 0) {
            console.log('[CONNECTION DEBUG] Removing connection warning toasts');
            warningElements.forEach(el => {
              if (el.textContent?.includes('Connection')) {
                el.remove();
              }
            });
          }
        } catch (error) {
          console.error('[CONNECTION DEBUG] Error removing toast warnings:', error);
        }
      }
    } else {
      console.log(`[CONNECTION DEBUG] Connection status unchanged during stability period`);
    }
    
    // Need to explicitly declare as null, not reassign
    window.setTimeout(() => {
      connectionStabilityTimeout = null;
    }, 0);
  }, STABILITY_THRESHOLD);
}, 2000, { leading: false, trailing: true }); // 2 second debounce with trailing edge execution

/**
 * A more resilient connection check that doesn't depend on specific tables or RPC
 * @returns Promise<boolean> - true if connected, false otherwise
 */
export const checkSupabaseConnection = async (): Promise<boolean> => {
  try {
    console.log('[CONNECTION DEBUG] Starting connection check, current status:', {
      isSupabaseConnected,
      connectionAttempts,
      lastConnectionStatus,
      isOffline: errorHandler.isOffline,
      browserOnline: typeof navigator !== 'undefined' && navigator.onLine
    });
    
    // If the browser reports we're offline, don't even try
    if (typeof navigator !== 'undefined' && !navigator.onLine) {
      console.log('[CONNECTION DEBUG] Browser reports offline, skipping connection check');
      updateConnectionStatus(false);
      return false;
    }
    
    // Check if the Supabase server is reachable using a simple HEAD request
    console.log('[CONNECTION DEBUG] Attempting HEAD request to Supabase');
    const response = await fetch(`${SUPABASE_URL}/rest/v1/`, {
      method: 'HEAD',
      headers: {
        'Content-Type': 'application/json',
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`
      }
    });
    
    console.log('[CONNECTION DEBUG] Supabase HEAD response:', {
      status: response.status,
      statusText: response.statusText,
      headers: Array.from(response.headers.entries())
    });
    
    // Consider connected if the server responds with any status < 500 (server error)
    const isConnected = response.status < 500;
    
    console.log('[CONNECTION DEBUG] Connection check result:', {
      isConnected,
      status: response.status,
      previousStatus: isSupabaseConnected
    });
    
    // Update internal states
    if (isConnected) {
      // Reset connection attempts on success
      connectionAttempts = 0;
      // Skip warning message on successful connection
      console.log('[CONNECTION DEBUG] Connection check successful');
    } else {
      connectionAttempts++;
      console.log(`[CONNECTION DEBUG] Connection attempt ${connectionAttempts} failed`);
    }
    
    // Always update connection status based on the result
    updateConnectionStatus(isConnected);
    return isConnected;
  } catch (error) {
    console.error('[CONNECTION DEBUG] Supabase connection check failed with exception:', error);
    isSupabaseConnected = false;
    connectionAttempts++;
    console.log(`[CONNECTION DEBUG] Connection attempt ${connectionAttempts} failed with exception`);
    updateConnectionStatus(false);
    return false;
  }
};

// Check connection status
export const isConnected = () => isSupabaseConnected;

// Generate a proper anonymous user ID using the uuid library
export const generateAnonymousUserId = () => {
  const anonymousId = `anonymous-${uuidv4()}`;
  return anonymousId;
};

// Preload an audio file from Supabase Storage
export const preloadAudioFile = async (bucketName: string, filePath: string): Promise<Blob | null> => {
  try {
    console.log(`Preloading audio file from Supabase Storage: ${bucketName}/${filePath}`);
    
    // First check if we're online
    if (errorHandler.isOffline) {
      console.warn('Cannot preload audio file: offline');
      throw new Error('Unable to download audio file: you are offline');
    }
    
    // Create signed URL for faster access
    const { data: signedURLData, error: signedURLError } = await supabase
      .storage
      .from(bucketName)
      .createSignedUrl(filePath, 60); // 60 seconds expiry
    
    if (signedURLError || !signedURLData?.signedUrl) {
      console.error('Error creating signed URL:', signedURLError);
      
      // Fall back to public URL
      const { data: publicURLData } = await supabase
        .storage
        .from(bucketName)
        .getPublicUrl(filePath);
      
      if (!publicURLData?.publicUrl) {
        throw new Error(`Failed to get URL for file: ${filePath}`);
      }
      
      console.log('Using public URL as fallback');
      const response = await fetch(publicURLData.publicUrl);
      if (!response.ok) {
        throw new Error(`Failed to download file: ${response.status} ${response.statusText}`);
      }
      
      return await response.blob();
    }
    
    // Use the signed URL for faster downloads
    console.log('Using signed URL for faster download');
    const response = await fetch(signedURLData.signedUrl);
    if (!response.ok) {
      throw new Error(`Failed to download file: ${response.status} ${response.statusText}`);
    }
    
    const blob = await response.blob();
    console.log(`Successfully downloaded ${blob.size} bytes`);
    return blob;
  } catch (error) {
    console.error('Error preloading audio file:', error);
    return null;
  }
};

// Start periodic connection checks
let connectionCheckInterval: ReturnType<typeof setInterval> | null = null;

const startConnectionChecks = () => {
  if (connectionCheckInterval) {
    clearInterval(connectionCheckInterval);
  }
  
  connectionCheckInterval = setInterval(() => {
    checkSupabaseConnection();
  }, CONNECTION_CHECK_INTERVAL);
  
  // Initial check
  checkSupabaseConnection();
};

// Start connection checks
startConnectionChecks();
